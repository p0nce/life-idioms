# Software Artifacts as elementary unit

I'd like to reason upon any kind of software artifacts:
- an octet
- a for loop
- a function
- a class object
- a whole product
- a product portfolio

In this blog these will be called "software artifacts".

A _Software Artifact_ has:

- **Existence.** Has a physical extent in lines of codes, documentation, or data presence `Extent(x)`.
  Arguably if it isn't there, then it doesn't exist.

- **Price.** For each artifact `x`, we note `ATM(x)` the amount of Attention/Time/Money gained by `x` existing.
  This is the cost to write the artifact, the cost to maintain it, selling it, etc. aggregated over its total lifetime (like _stocks_).

  More often than not, this ATM isn't known.


## Equality

Two software artifacts `A` and `B` are **equal** iff `Extent(A) == Extent(B)`.
They have equal ATM.


## Composition

A software artifact is **composed of** other software artifacts, down to a unit level of minimum physical existence.
For example, the for loop is made of the `for` keyword, itself composed of `f`, `o`, `r` characters.

While it is difficult to think of an ATM just for a `f` letter, we postulate that it exists.

Composition is noted `A + B`.


## Independence

Two artifacts `A` and `B` are **independent** if for every artifact `a` that compose `A`, `a` cannot be found composing `B`.

Example: 
```
Company Comcom has two completely independent software products Toto and Titi,
that don't share a single file.
```


Postulate: if `A` and `B` are independent, then `ATM(A + B) = ATM(A) + ATM(B)`.


Example:
```
The Toto product earns $1000 a month and the Titi product $2000 a month, 
without any attention or time commitment, without sharing a single file.
Since they are independent, ATM(Titi + Toto) = ATM(Titi) + ATM(Toto). 
Their earnings add up independently.
Note that we still don't know the actual value of ATM(Titi) or ATM(Toto).
```


## Decomposition rule

If software artifacts `A` and `B` are not independent, there exist 3 independent artifacts `a`, `b`, `C` such that:

- `A == C + a`
- `B == C + b`

In this case: `ATM(A + B) = 2.ATM(C) + ATM(a) + ATM(b)`


Example:
```
The Toto and Titi products now share some library code Baba.
Toto earns $10000 a month and the Titi product only $100 a month, 
without any attention or time commitment.
ATM(Titi + Toto) = 2.ATM(Baba) + ATM(Toto-specific code) + ATM(Titi-specific code)
```

Intuitively, we find that the most reused software artifacts have the most impact in the earnings of Comcom the company.
In this case, `ATM(Toto-specific-code)` is probably large, but we don't know it's exact value.
We _also_ don't know the split between `Baba` and `Toto-specific code`.


## We still don't know the ATM value

In typical practice, a proxy for knowing `ATM(x)` is the very measurable _immediate sales generated by x_.

**This is wrong.**

But this is only an approximation:
- the full cost is the integral over time of Attention, Time and Money. Not the immediate Money generation.
  ATM is to software, what stocks are to companies.
- Sales do not tell the story of Time and Attention consumed by `x`. A fact often lamented in "technical debt" rants.

**While ATM is the primary measure of success in an artifact, we have only a passing understanding of its real value. Instead what is used is a short-term, partial, proxy measurement for ATM: sales.**